<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<link rel="stylesheet" type="text/css" href="../css/alertbox.css">
<script>
var support = {audioContext: true, src_start: true};
if(window.AudioContext)
  audioctx = new window.AudioContext();
else{
  support.audioContext = false;
  audioctx = new (window.webkitAudioContext)();
}
var gainNode = audioctx.createGain();
gainNode.gain.value = 0.5;
gainNode.connect(audioctx.destination);
var currentTime = 0.0;
var bpm = 100;
var runningNotes = new Set();

function genFakePiano(){
  var buff = audioctx.createBuffer(1, 44100 * 2, 44100);
  var dat = buff.getChannelData(0);
  var k = 440 / 44100 * Math.PI * 2;
  for(var t = 0; t < 44100 * 2; t++){
    var sum = 0;
    for(var n = 1; n < 20; n++){
      sum += Math.sin(k * n * t) * Math.exp(-(n - 1) * 0.25);
    }
    dat[t] = sum * Math.exp(-t / (44100 * 0.5)) * 0.25;
  }
  return buff;
}

var soundBank =
  {fakePno:
    {sample: genFakePiano(), center: 69}
  };
var fakePno = soundBank.fakePno;
function note(pitch,start,end){
/*
  var osc = audioctx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = Math.pow(2, (pitch - 69) / 12) * 440;
  osc.connect(gainNode);
  osc.start(currentTime + start * (60 / bpm));
  osc.stop(currentTime + (start + duration) * (60 / bpm));
  runningNotes.add(osc);
  osc.onended = function(){ runningNotes.delete(osc); };
*/
  var src = audioctx.createBufferSource();
  var env = audioctx.createGain();
  src.buffer = fakePno.sample;
  src.playbackRate.value = Math.pow(2, (pitch - fakePno.center) / 12);
  src.loop = true;
  src.loopStart = 0;
  src.loopEnd = 123;
  src.connect(env);
  env.connect(gainNode);
  var startTime = currentTime + start;
  if(src.start)
    src.start(startTime);
  else {
    support.src_start = 'false';
    src.noteOn(startTime);
  }

  var endtime = currentTime + end;
  env.gain.setValueAtTime(1, endtime - 0.05);
  env.gain.linearRampToValueAtTime(0, endtime);
  if(src.stop)
    src.stop(endtime);
  else {
    src.noteOff(endTime);
  }
  runningNotes.add(src);
  src.onended = function(){ runningNotes.delete(src); };
}

function play(){
  var C=60,D=62,E=64,F=65,G=67,A=69,B=71;
  var q=0.25,h=0.5;
  currentTime = audioctx.currentTime;
  /*note(G, 0, 0.5);
  note(E, 0.5, 0.5);
  note(E, 1, 1);

  note(F, 2, 0.5);
  note(D, 2.5, 0.5);
  note(D, 3, 1);

  note(C, 4, 0.5);
  note(D, 4.5, 0.5);
  note(E, 5, 0.5);
  note(F, 5.5, 0.5);
  note(G, 6, 0.5);
  note(G, 6.5, 0.5);
  note(G, 7, 1);

  note(G, 8, 0.5);
  note(E, 8.5, 0.5);
  note(E, 9, 1);

  note(F, 10, 0.5);
  note(D, 10.5, 0.5);
  note(D, 11, 1);

  note(C, 12, 0.5);
  note(E, 12.5, 0.5);
  note(G, 13, 0.5);
  note(G, 13.5, 0.5);
  note(E, 14, 2);

  note(D, 16, 0.5);
  note(D, 16.5, 0.5);
  note(D, 17, 0.5);
  note(D, 17.5, 0.5);
  note(D, 18, 0.5);
  note(E, 18.5, 0.5);
  note(F, 19, 1);

  note(E, 20, 0.5);
  note(E, 20.5, 0.5);
  note(E, 21, 0.5);
  note(E, 21.5, 0.5);
  note(E, 22, 0.5);
  note(F, 22.5, 0.5);
  note(G, 23, 1);

  note(G, 24, 0.5);
  note(E, 24.5, 0.5);
  note(E, 25, 1);

  note(F, 26, 0.5);
  note(D, 26.5, 0.5);
  note(D, 27, 1);

  note(C, 28, 0.5);
  note(E, 28.5, 0.5);
  note(G, 29, 0.5);
  note(G, 29.5, 0.5);
  note(C, 30, 2);*/

  // twinkle twinkle little star
  bpm = 100;
  var pitch = [
    C,h,C,h,G,h,G,h,A,h,A,h,G,1,
    F,h,F,h,E,h,E,h,D,h,D,h,C,1,
    G,h,G,h,F,h,F,h,E,h,E,h,D,1,
    G,h,G,h,F,h,F,h,E,h,E,h,D,1,
    C,h,C,h,G,h,G,h,A,h,A,h,G,1,
    F,h,F,h,E,h,E,h,D,h,D,h,C,1,
  ];

  // Yee
  bpm = 120;
  var pitch = [
    C,1/3,D,2/3,C,1/3,
    E,1,E,1,D,2/3,C,1,D,4/3,G,2/3,G,1,D,1/3,E,2/3,D,1/3,
    F,1,F,1,G,2/3,A,2/3,0,1/3,
    B,1
  ];

  // little bee
  /*bpm = 100;
  var pitch = [
    G,h,E,h,E,1,F,h,D,h,D,1,
    C,h,D,h,E,h,F,h,G,h,G,h,G,1,
    G,h,E,h,E,1,F,h,D,h,D,1,
    C,h,E,h,G,h,G,h,E,2,
    D,h,D,h,D,h,D,h,D,h,E,h,F,1,
    E,h,E,h,E,h,E,h,E,h,F,h,G,1,
    G,h,E,h,E,1,F,h,D,h,D,1,
    C,h,E,h,G,h,G,h,C,2,
  ];*/
  /*var ff = 0;
  for(var i=0; i<pitch.length; i+=2){
    note(pitch[i], ff, pitch[i+1]);
    ff += pitch[i+1];
  }*/
  var code = document.getElementById('code').value;
  var read = new Reader(code);
  var result = [];
  while(!read.atEnd()){
    result.push(read.nextInstr());
  }
  result = readMusic(code);
  combineTies(result.parts);
  combineTime(result.parts, result.tempo);
  result = result.parts;
  for(var id in result){
    var part = result[id];
    var time = part.time;
    var notes = part.notes;
    for(var i=0; i<notes.length; i++){
      var chord = notes[i].chord;
      for(var j=0; j<chord.length; j++){
        note(chord[j].pitch, time[i], time[chord[j].end]);
      }
    }
  }
  document.getElementById('warn').innerText = JSON.stringify(support);
}

function stop(){
  for(var node of runningNotes){
    node.stop();
  }
  runningNotes.clear();
}

// for iOS only
var audioUnlocked = false;
window.addEventListener('touchend', unlock, false);
function unlock(){
  if(audioUnlocked) return;
  var src = audioctx.createBufferSource();

  src.buffer = fakePno.sample;

  src.connect(gainNode);
  src.start(0);
  document.getElementById('warn').innerHTML = '';
  window.removeEventListener('touchend', unlock);
}
if(/iP[ao]d|iPhone/.test(navigator.userAgent)){
  document.getElementById('warn').innerHTML = 'Click anywhere on this page to unlock the AudioContext';
}

// scream!
function changeInstr(name){
  var instrument = soundBank[name];
  if(instrument){
    fakePno = instrument;
  }
}

function loadSmp(where, instr, prop){
  var req = new XMLHttpRequest();

  req.open('GET', where, true);
  req.responseType = 'arraybuffer';

  req.onload = function(){
    var dat = req.response;
    audioctx.decodeAudioData(dat, function(buffer){
      prop.sample = buffer;
      soundBank[instr] = prop;
    }, function(){
      throw new Error('Cannot decode audio');
    });
  };
  req.send();
}

function Reader(str){
  this.data = str;
  this.pos = 0;
  this.keyAccidental = [ 0, 0, 0, 0, 0, 0, 0];
  this.keyPitch = [10, 12, 1, 3, 5, 6, 8];
  this.octave = 4;
  this.duration = 4;
  this.volume = 80;
  this.part = 0;
  this.partStates = {};
  this.chord = false;
  this.storedOctave = this.octave;
  this.storedVolume = this.volume;
}

Reader.prototype.next = function(){
  return this.data.charAt(this.pos++);
};

Reader.prototype.atEnd = function(){
  return this.pos >= this.data.length;
};

Reader.prototype.peek = function(){
  return this.data.charAt(this.pos);
};

Reader.prototype.rewind = function(){
  --this.pos;
};

Reader.prototype.nextInt = function(){
  var result = null;
  while (!this.atEnd()){
    var char = this.next();
    if (char >= '0' && char <= '9'){
      result = result*10 + parseInt(char);
    }
    else {
      this.rewind();
      break;
    }
  }
  return result;
};

Reader.prototype.nextFloat = function(){
  var integ = this.nextInt();
  if(integ === null){
    return null;
  }
  if(this.next() !== '.'){
    this.rewind();
    return integ;
  }
  var frac = 0;
  var base = 0.1;
  while (!this.atEnd()){
    var char = this.next();
    if (char >= '0' && char <= '9'){
      frac += parseInt(char) * base;
      base *= 0.1;
    }
    else {
      this.rewind();
      break;
    }
  }
  return integ + frac;
};

Reader.prototype.skipSpace = function(){
  var ch;
  do {
    ch = this.next();
  } while(/^\s$/.test(ch)) ;
  this.rewind();
};

Reader.prototype.nextInstr = function(){
  var ch;
  this.skipSpace();
  ch = this.next();
  var num;
  switch(ch.toUpperCase()){
    case 'C': case 'D': case 'E': case 'F': case 'G':
    case 'A': case 'B':
      return this.readNote(ch.toUpperCase());
    case 'K':
      return this.readKey();
    case ',': case '<':
      return {type: 'octave', octave: --this.octave};
    case "'": case '>':
      return {type: 'octave', octave: ++this.octave};
    case 'O':
      num = this.nextInt();
      if (num === null) num = 4;
      this.octave = num;
      return {type: 'octave', octave: this.octave};
    case 'L':
      num = this.nextInt();
      if(this.chord) return null;
      if (num === null || num < 1) num = 4;
      this.duration = num;
      return {type: 'duration', duration: this.duration};
    case '!':
      return this.readPart();
    case '/':
      if(!this.chord)
        this.switchChord(true);
      return {type: 'chord'};
    case 'P':
      return this.readRest();
    case 'V':
      num = this.nextInt();
      if (num === null) num = 80;
      this.volume = num;
      return {type:'volume', volume: this.volume};
    case 'T':
      num = this.nextFloat();
      if (this.chord) return null;
      if (num === null || num < 20) num = 120;
      return {type: 'tempo', bpm: num};
    default:
      return null;
  }
};

Reader.prototype.readNote = function(pitch){
  var ptc = pitch.charCodeAt(0) - 65;
  var acci;
  var ch = this.next();
  switch(ch){
    case '+': case '#':
      ch = this.next();
      if(ch == '+' || ch == '#'){
        acci = 2;
      }
      else{
        this.rewind();
        acci = 1;
      }
      break;
    case '-':
      ch = this.next();
      if(ch == '-'){
        acci = -2;
      }
      else{
        this.rewind();
        acci = -1;
      }
      break;
    case '@':
      acci = 0;
      break;
    default:
      acci = this.keyAccidental[ptc];
      this.rewind();
  }
  pitch = this.octave * 12 + this.keyPitch[ptc] + acci;

  var duration = this.nextInt();
  if(duration == null){
    duration = this.duration;
  }

  var dots = 0;
  ch = this.next();
  while (ch == '.'){
    dots++;
    ch = this.next();
  }
  this.rewind();

  var volume = this.volume;
  var chord = this.chord;
  if(chord){
    this.switchChord(false);
  }
  else{
    this.storedOctave = this.octave;
    this.storedVolume = this.volume;
  }

  ch = this.next();
  var tied = false;
  if(ch == '~'){
    tied = true;
  }
  else{
    this.rewind();
  }
  return {type: 'note', duration: duration, dots: dots, pitch: pitch,
  chord: chord, tied: tied, volume: volume};
};

Reader.prototype.readRest = function(){
  var duration = this.nextInt();
  if(duration == null){
    duration = this.duration;
  }

  var dots = 0;
  ch = this.next();
  while (ch == '.'){
    dots++;
    ch = this.next();
  }
  this.rewind();

  var chord = this.chord;
  if(chord){
    this.switchChord(false);
  }
  else{
    this.storedOctave = this.octave;
    this.storedVolume = this.volume;
  }

  return {type:'rest', duration: duration, dots: dots, chord: chord};
};

Reader.prototype.switchChord = function(){
  this.chord = !this.chord;
  var num = this.octave;
  this.octave = this.storedOctave;
  this.storedOctave = num;
  num = this.volume;
  this.volume = this.storedVolume;
  this.storedVolume = num;
};

Reader.prototype.endChord = function(){
  if(this.chord){
    this.octave = this.storedOctave;
    this.volume = this.storedVolume;
    this.chord = false;
  }
  else{
    this.storedOctave = this.octave;
    this.storedVolume = this.volume;
  }
};

Reader.prototype.readKey = function(){
  var ch = this.next().toUpperCase();
  if(!/[A-G]/.test(ch)){
    return null;
  }
  var key = ch.charCodeAt(0) - 64;
  key = key > 2 ? key - 2 : key + 5;
  var acci = 0;
  ch = this.next();
  switch(ch){
    case '+': case '#':
      acci = 1;
      break;
    case '-':
      acci = -1;
      break;
    default:
      acci = 0;
      this.rewind();
  }
  var keyTable = [
    //       pitch
    //A  B  C  D  E  F  G     key
    [ 0, 0, 0, 0, 0, 0, 0], // C
    [ 0, 0,+1, 0, 0,+1, 0], // D
    [ 0, 0,+1,+1, 0,+1,+1], // E
    [ 0,-1, 0, 0, 0, 0, 0], // F
    [ 0, 0, 0, 0, 0,+1, 0], // G
    [ 0, 0,+1, 0, 0,+1,+1], // A
    [+1, 0,+1,+1, 0,+1,+1]  // B
  ];
  var legal = ["ooo","oox","oox","xoo","oox","oox","oox"];
  if(legal[key-1].charAt(acci+1) == 'x'){
    acci = 0;
    this.rewind();
  }
  if(this.chord) return null;
  for(var i=0;i<7;i++){
    this.keyAccidental[i] = keyTable[key-1][i] + acci;
  }
  return {type: 'key', key: key, accidential: acci};
};

Reader.prototype.readPart = function(){
  this.endChord();
  var num = this.nextInt();
  if(!num) num = 0;
  this.partStates[this.part] = {
    octave: this.octave,
    duration: this.duration,
    volume: this.volume
  };
  var state = this.partStates[num];
  if (state){
    this.octave = state.octave;
    this.duration = state.duration;
    this.volume = state.volume;
  }
  else{
    this.octave = 4;
    this.duration = 4;
    this.volume = 80;
  }
  this.part = num;
  return {type: 'part', part: num};
};

function readMusic(code){
  var read = new Reader(code);
  var part = {id: 0, notes: []};
  var parts = {0: part};
  var note;
  var pitch;
  var pos = 0;
  var tempoChange = [];
  while(!read.atEnd()){
    var instr = read.nextInstr();
    if(instr == null){
      continue; // invalid character or instruction
    }
    if(instr.type == 'note'){
      pitch = {pitch: instr.pitch, tied: instr.tied, volume: instr.volume};
      if(instr.chord){
        note = part.notes[part.notes.length - 1];
        note.chord.push(pitch);
      }
      else{
        var len = 4 / instr.duration;
        if(instr.dots == 1) len *= 1.5;
        if(instr.dots >= 2) len *= 1.75;
        note = {chord: [pitch], len: len, pos: pos};
        pos += len;
        part.notes.push(note);
      }
    }
    else if(instr.type == 'rest'){
      if(!instr.chord){
        var len = 4 / instr.duration;
        if(instr.dots == 1) len *= 1.5;
        if(instr.dots >= 2) len *= 1.75;
        note = {chord: [], len: len, pos: pos};
        pos += len;
        part.notes.push(note);
      }
    }
    else if(instr.type == 'part'){
      var newPart = parts[instr.part];
      if(newPart){
        part = newPart;
        if(part.notes.length > 0){
          note = part.notes[part.notes.length-1];
          pos = note.pos + note.len;
        }
        else {
          pos = 0;
        }
      }
      else{
        part = {id: instr.part, notes: []};
        pos = 0;
        parts[instr.part] = part;
      }
    }
    else if(instr.type == 'tempo'){
      tempoChange.push({pos: pos, bpm: instr.bpm});
    }
  }
  tempoChange.sort(function(a,b){
    a = a.pos;
    b = b.pos;
    return a<b ? -1 : (a>b ? 1 : 0);
  });
  if(tempoChange.length == 0 || tempoChange[0].pos > 0){
    tempoChange.unshift({pos: 0, bpm: 120});
  }
  return {parts: parts, tempo: tempoChange};
}

function combineTies(parts){
  for(var id in parts){
    var part = parts[id];
    var notes = part.notes;
    for(var i=0; i<notes.length; i++){
      var chord = notes[i].chord;
      for(var j=0; j<chord.length; j++){
        if(chord[j].tied){
          var k, m;
          for(k=i+1; k<notes.length; k++){
            var next = notes[k].chord;
            for(m=0; m<next.length; m++){
              if(next[m].pitch == chord[j].pitch){
                break;
              }
            }
            var again = false;
            if (m < next.length){
              if(next[m].tied){
                again = true;
              }
              next[m] = next[next.length-1];
              next.length -= 1;
            }
            else{
              k--;
            }
            if(!again)
              break;
          }
          if(k >= notes.length) k = notes.length-1;
          chord[j].end = k+1;
        }
        else{
          chord[j].end = i+1;
        }
      }
    }
  }
  return parts;
}

function combineTime(parts, tempo){
  var tempoTime = [0];
  var time = 0;
  for(var i=1; i<tempo.length; i++){
    time += (tempo[i].pos - tempo[i-1].pos) * (60/tempo[i-1].bpm);
    tempoTime.push(time);
  }
  for(var id in parts){
    var part = parts[id];
    part.time = [0];
    var i = 0;
    var notes = part.notes;
    for(var j=0; j<notes.length; j++){
      var endPos = notes[j].pos + notes[j].len;
      do {
        i++;
      } while(i < tempo.length && tempo[i].pos < endPos);
      i--;
      part.time.push(tempoTime[i] + (endPos - tempo[i].pos) * (60/tempo[i].bpm));
    }
  }
}
</script>
</head>
<body>
<p><textarea id='code'></textarea></p>
<input type='button' value='Play' onclick='play()'>
<input type='button' value='Stop' onclick='stop()'>
<p>
  <button onclick='changeInstr("fakePno")'>fakePno</button>
  <button onclick='changeInstr("scream")'>scream</button>
</p>
<p id='warn'></p>

<!-- alert box -->
  <div id='alert' class='alert-box' style='visibility: hidden;'>
    <div class='title'>
      <span>Error</span>
      <input id='close' class='x' value='X' type='button'>
    </div>
    <pre class='description' id='description'>
錯誤訊息會顯示在這裡
    </pre>
  </div>
  <script src='../js/alertbox.js'></script>
<!-- end of alert box -->
<script>
  loadSmp('sound/scream.wav', 'scream', {center: 72});
</script>
</body>
</html>
